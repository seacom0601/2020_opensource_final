[커뮤니케이션 문서화]

[https://github.com/OpenRCT2/OpenRCT2 : 롤러 코스터 타이쿤 관련 오픈 소스 레포, c ++ 기반, 깔끔한 readme, 체계적인 소통 구조] 프로젝트를 분석합니다. 이중에서 4가지 파일의 커뮤니케이션을 선정하여 문서화하였습니다.

1) 작업 hpp 파일을 별도의 h 및 cpp 파일로 분할

SmallSceneryPlace 분할 / 제거
Remove Scenery에 대한 실행 취소 기능 추가
리팩터링은 풍선 및 배너 작업 hpp => h / cpp
리팩터링은 모든 작업 * .hpp 파일의 이름을 * .cpp로 변경

테스트를 위한 업데이트가 포함
정적 함수 선언을 .h 파일로 이동
이전에 암시적이었던 다양한 파일에 명시적 포함 추가
(필수 헤더는 작업 hpp 파일에 중첩된 포함이었고 작업 .h 파일에 해당 헤더가 포함되지 않음)
사용하지 않는 가져오기를 방지하기 위해 RideSetStatus 문자열 열거형을 cpp 파일로 이동

2) "하이브리드 코스터 "탑승 유형 추가

이 커뮤니케이션은 "하이브리드 코스터"탑승 유형을 추가. ‘추가’에 중점을 둠.
턴 추가
대각선 경사 추가
은행 전환 추가
대각선 뱅크 전환 추가
뱅크 턴, 경사 회전, s굴곡 추가
동적 결함을 수정
부스터 수정
코르크 나사 제거하고 승차 데이터 설정 및 승차 평가 기능 구현
가파른 회전 및 완만하거나 가파른 곳에서 결함 수정을 한 것으로 나타남
결함 있는 분할 트랙 스프라이트

작은 나선에서 잘못된 스프라이트 인덱스 수정

대형 평면에서 가파른 조각에 대한 지지대 추가

b지원으로 버그 수정

쿼터 루프 지원 추가

트랙 요소 세트 완성

트랙 조각이 강조 표시될 때 이상한 색상 수정

3) 강력한 열거형을 사용하도록 열거형 리팩터링

현재 많은 코드에서 약한 열거형을 사용 -> 전역 네임 스페이스를 오염시키는 상수
C ++에서 선호하는 방법은 '열거형 클래스'를 의미하는 강력한 열거형을 사용하는 것
열거 (여러 명시 상수를 포함할 수 있고 값이 값의 범위로 제한된다)
상수의 값은 열거 형의 기본 유형으로 알려진 정수 유형의 값
1>기본 형식이 고정되지 않은 범위가 지정되지 않은 열거 형식을 선언한다 이 경우 기본 형식은 모든 열거자 값을 나타낼 수 있는 구현 정의 정수 형식이다. 이 형식은 int열거 자의 값이 int또는 unsigned int이다. 열거 목록이 비어 열거값 0 하나 열거했다는 것처럼, 기본 타입이다.

2>기본 형식이 고정된 범위가 지정되지 않은 열거 형을 선언한다. 범위가 지정되지 않은 열거형에 대한 불투명 한 열거형 선언은 기본 형식을 지정해야 한다. 각 열거 자는 열거 형 유형 (즉, name)의 명명된 상수가 되어 바깥 쪽 범위에 표시되며 상수가 필요할 때마다 사용할 수 있다.

enum 클래스가 일반 enum보다 선호되는 이유는 무엇일까?
1> enum classes-열거자 이름은 열거형에 로컬 이며 해당 값은 암시 적으로 다른 유형 (예 : another 또는 )으로 변환 되지 않는다.

2> Plain enums-열거자 이름이 열거 형과 동일한 범위에 있고 해당 값이 암시 적으로 정수 및 기타 유형으로 변환되는 경우

그러므로 enum classes는 잠재적으로 버그로 이어질 수 있는 놀라움을 덜 발생시키기 때문에 선호되어야 한다.

4) 라이드 유형 메타 데이터 테이블을 RideTypeDescriptors로 이동

현재 승차 유형 정보는 코드베이스 전체에 걸쳐 수많은 테이블에 저장된다.
이 프로젝트의 목표는 라이드 유형 당 하나의 파일이 있는 RideTypeDescriptor에 넣는 것이다.
이 프로젝트의 이점은 다음과 같다.

정보를 더 쉽게 찾을 수 있다
새로운 라이드 유형을 더 쉽게 추가할 수 있다.
라이드 유형을 사물로 쉽게 전환할 수 있다.
이 프로젝트는 대략 두 단계로 구성된다.
• 1 단계 : 모든 메타 데이터를 RTD로 이동
• 2 단계 : 정보 읽기 중지 RideTypeDescriptors[ride->type]-기능을 사용하여 RTD를 가져온 다음 읽어온다.
5) 새 창 프레임 워크

훨씬 더 많은 코드를 재사용 가능하고 객체 지향적으로 만들어 새 창을 쉽게 만들 수 있는 새 창 프레임 워크를 만든다.
새 윈도우 시스템은 다음과 같아야 한다.
• 다른 창과 위젯이 파생되는 Window 및 Widget에 대한 기본 클래스가 있다.
• 위젯에는 키보드/마우스 이벤트가 있어야한다.
• 창에서 탭 페이지를 분리하여 두 창에서 공유할 수 있다.
• 창에 대한 탭 컨트롤을 자동으로 처리 (예: 탭 컨트롤 위젯)
• 탭에 표시되는 애니메이션 재사용
• 그리드 또는 스택 패널을 사용하여 자동으로 위젯 레이아웃 (다른 글꼴 크기 해결)
• x, y에 문자열을 그리는 대신 레이블 위젯을 사용해야한다.
• 데이터 그리드는 이를 채우기 위한 어댑터, 정렬 및 헤더 처리를 위한 공통 코드가 있는 자체 위젯이어야 한다.
